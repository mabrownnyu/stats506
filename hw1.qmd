---
title: "Homework 1"
format: 
  html:
    embed-resources: true
editor: visual
author: "Megan Brown"
---

Github repo: <https://github.com/mabrownnyu/stats506>

# Problem 1 - Abalone Data

## Problem 1(a)

```{r}

# column names from abalone.names
columns <- c("sex", "length", "diameter", "height", "whole_weight",
             "shucked_weight", "viscera_weight", "shell_weight", "rings")

# data from abalone.data
df <- read.csv('datasets/abalone/abalone.data', header=FALSE)

# set new column names
names(df) <- columns
```

## Problem 1(b)

```{r}

# count the number of records by sex 
table(df$sex)
```

There are 1,307 females, 1,342 infants, and 1,528 males.

## Problem 1(c)

### Problem 1(c)(1)

I found the R function for correlation from [this blog post](https://statsandr.com/blog/correlation-coefficient-and-correlation-test-in-r/).

```{r}

# correlation between different weights and rings
print(paste0("Whole Weight: ", cor(df$whole_weight, df$rings)))

print(paste0("Shucked Weight: ", cor(df$shucked_weight, df$rings)))

print(paste0("Viscera Weight: ", cor(df$viscera_weight, df$rings)))

print(paste0("Shell Weight: ", cor(df$shell_weight, df$rings)))

```

Shell weight is most correlated with rings.

### Problem 1(c)(2)

```{r}
# split dataframes by sex
males <- df[df$sex == "M",]
females <- df[df$sex == "F",]
infants <- df[df$sex == "I",]

# output correlations
print(paste0("Males: ", cor(males$shell_weight, males$rings)))
print(paste0("Females: ", cor(females$shell_weight, females$rings)))
print(paste0("Infants: ", cor(infants$shell_weight, infants$rings)))

```

For infants, shell weight was most correlated with rings.

### Problem 1(c)(3)

```{r}
# get the record where the number of rings is the highest number of rings
df[df$rings == max(df$rings),]
```

For the abalone with the most rings, the whole weight was 1.8075g, the shucked weight was 0.7055g, the viscera weight was 0.3215g, and the shell weight was 0.475g.

### Problem 1(c)(4)

```{r}
# calculate number of abalones with viscera weight > shell weight
numerator <- nrow(df[df$viscera_weight > df$shell_weight,]) 

# get total number of abalones in data
denominator <- nrow(df)

# print percentage
print(100*numerator/denominator)
```

The percentage of abalones for which the viscera weight was greater than the shell weight was 6.51%.

## Problem 1(d)

```{r}

# calculate correlations
male_correlations <- cor(males[,c("whole_weight", "shucked_weight",
                                  "viscera_weight", "shell_weight")], males$rings)
female_correlations <- cor(females[,c("whole_weight", "shucked_weight", 
                                      "viscera_weight", "shell_weight")], females$rings)
infant_correlations <- cor(infants[,c("whole_weight", "shucked_weight", 
                                      "viscera_weight", "shell_weight")], infants$rings)

# create dataframe from correlations
correlations <- data.frame(cbind(male_correlations, female_correlations,
                                 infant_correlations))
names(correlations) <- c("M (rings)", "F (rings)", "I (rings)")

correlations
```

## Problem 1(e)

First, testing the difference between males and females.

```{r}
t.test(males$rings, females$rings)
```

Then, testing the difference between males and infants.

```{r}
t.test(males$rings, infants$rings)
```

Lastly, testing the difference between females and infants.

```{r}
t.test(females$rings, infants$rings)
```

Each group has a statistically significant difference in the number of rings among the group. Particularly, infants had an average of 8 rings, and males and females had an average of 10.7 and 11.1 rings, respectively. While the magnitude of the difference between the number of rings between males and females is smaller, the different is statistically significant.

# Problem 2 - Food Expenditure Data

## Problem 2(a)

```{r}
# read CSV of food expenditures
df <- read.csv("datasets/food_expenditure.csv")
```

## Problem 2(b)

```{r}
# rename columns to be more legible
names(df) <- c("id", "age", "n_household", "state", "currency", 
               "food_spending", "grocery_spending", "dining_spending",
               "misc_spending", "n_dineout", "alcohol", "food_assistance"
               )
```

## Problem 2(c)

```{r}
# print # observations
print(paste0("Number of observations: ", nrow(df)))

# filter to only USD
df <- df[df$currency == "USD", ]

# print remaining # of observations
print(paste0("Number of observations (only USD): ", nrow(df)))

```

## Problem 2(d)

```{r}
summary(df$age)
```

```{r}
# filter out age >= 99
df <- df[df$age <= 99, ]

# filter out age < 18
df <- df[df$age >= 18, ]

# filter out where age is NA
df <- df[!is.na(df$age), ]
```

I removed all minors under the age of 18 and anyone older than 99. I also removed records where the age is not reported.

## Problem 2(e)

```{r}
summary(df$state)
```

```{r}
# filter out NA states, XX states, and empty string states
df <- df[!is.na(df$state) & df$state != "XX" & df$state != "", ]
```

I removed all records where state is not reported, where the state is "XX", or where state is an empty string.

## Problem 2(f)

```{r}

# convert values to numeric
df$food_spending <- as.numeric(df$food_spending)
df$grocery_spending <- as.numeric(df$grocery_spending)
df$dining_spending <- as.numeric(df$dining_spending)
df$misc_spending <- as.numeric(df$misc_spending)

# filter out NAs
df <- df[!is.na(df$food_spending), ]
df <- df[!is.na(df$grocery_spending), ]
df <- df[!is.na(df$dining_spending), ]
df <- df[!is.na(df$misc_spending), ]

         
# filter out food expenditures less than 0
df <- df[(df$food_spending >= 0)
         & (df$grocery_spending >= 0)
         & (df$dining_spending >= 0)
         & (df$misc_spending >= 0), ]
```

I first converted food spending to numeric values. Then, I filtered out records where a type of food spending was not reported. Lastly, I filtered out records where the level of food spending was a negative amount.

## Problem 2(g)

```{r}
summary(df$n_dineout)
```

```{r}
# filter out records where # of dineouts is NA
df <- df[!is.na(df$n_dineout), ]

# filter out records where people report dining more 
# than 21 times per week (3 times per day)
df <- df[df$n_dineout <= 21, ]
```

I filtered out records where the number of dineouts was NA and where individuals reported dining out more than 21 times (more than three meals per day).

## Problem 2(h)

```{r}
nrow(df)
```

The total number of remaining observations is 127.

# Problem 3

## Problem 3(a)

I used [this stackoverflow post](https://stackoverflow.com/questions/3476782/check-if-the-number-is-integer) to figure out how to detect integers in R when passing a datatype double that is an integer.

```{r}
#' nextCollatz
#'
#' @param num A positive integer
#'
#' @returns The next value in the Collatz sequence
nextCollatz <- function(num){
  if (num <= 0 | num %% 1 != 0){
    print("Must input positive integer.")
    return()
  }
  
  num <- as.integer(num)
  # if num is even, return n/2 
  if (num %% 2 == 0){
    num = num / 2
    
  }
  # if num is odd, return 3n + 1
  else{
    num <- 3 * num + 1
  }
  
  # convert value to integer and return 
  num <- as.integer(num)
  return(num)
}
```

```{r}
nextCollatz(5)
```

```{r}
nextCollatz(16)
```

## Problem 3(b)

```{r}
#' collatzSequence
#'
#' @param num a positive integer 
#'
#' @returns a list containing `sequence` and `length`, `sequence` 
#' is the full Collatz Sequence for input `num`, and `length` is 
#' the length of the sequence
collatzSequence <- function(num){
  
  # return if not a positive integer
  if (num <= 0 | num %% 1 != 0){
    print("Must input positive integer.")
    return()
  }
  
  # initialize sequnce with input number
  sequence <- c(num)

  # while we have not reached 1, get the next Collatz number
  # and add it to the sequence 
  while (num != 1){
    num <- nextCollatz(num)
    sequence <- append(sequence, num)
  }
  
  # return the sequence 
  output <- list("sequence"=sequence, 
                 "length"=length(sequence))
  return(output)
}
```

```{r}
collatzSequence(5)
```

```{r}
collatzSequence(19)
```

## Problem 3(c)

```{r}

# set init values
min_len = 1e9
min_val = 0

max_len = 0
max_val = 0

for (val in 100:500){
  
  # get sequence and length for value
  seq_len <- collatzSequence(val)

  # if the sequence length is less than the min length,
  # save the sequence length and the index
  if (seq_len$length < min_len){
    min_len <- seq_len$length 
    min_val <- val
  }
  
  # if the sequence length is greater than the maximum length,
  # save the sequence length and the index 
  if (seq_len$length > max_len){
    max_len <- seq_len$length 
    max_val <- val 
  }
}
```

```{r}
print(paste0("Shortest sequence start: ", min_val))
print(paste0("Shortest sequence length: ", min_len))

print(paste0("Longest sequence start: ", max_val))
print(paste0("Longest sequence length: ", max_len))
```
